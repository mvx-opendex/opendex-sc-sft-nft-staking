// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct OpendexSftNftStakingProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for OpendexSftNftStakingProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = OpendexSftNftStakingProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        OpendexSftNftStakingProxyMethods { wrapped_tx: tx }
    }
}

pub struct OpendexSftNftStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> OpendexSftNftStakingProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<u32>,
        Arg6: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        staking_sft_collection_id: Arg0,
        min_nonce_id: Arg1,
        max_nonce_id: Arg2,
        reward_token: Arg3,
        fee_receiver: Arg4,
        performance_fee: Arg5,
        funder: Arg6,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&staking_sft_collection_id)
            .argument(&min_nonce_id)
            .argument(&max_nonce_id)
            .argument(&reward_token)
            .argument(&fee_receiver)
            .argument(&performance_fee)
            .argument(&funder)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OpendexSftNftStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OpendexSftNftStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn staking_sft_collection_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingSftCollectionId")
            .original_result()
    }

    pub fn min_nonce_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinNonceId")
            .original_result()
    }

    pub fn max_nonce_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxNonceId")
            .original_result()
    }

    pub fn reward_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardToken")
            .original_result()
    }

    pub fn staked_nft_collection_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakedNftCollectionId")
            .original_result()
    }

    /// Return amount of reward per second (multiplied by 10^10 for precision) 
    pub fn reward_per_second(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardPerSecond")
            .original_result()
    }

    pub fn total_staked(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStaked")
            .original_result()
    }

    pub fn fee_receiver(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFeeReceiver")
            .original_result()
    }

    pub fn performance_fee_percent(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPerformanceFeePercent")
            .original_result()
    }

    pub fn reward_end_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardPeriodEnd")
            .original_result()
    }

    pub fn reward_start_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardStartTime")
            .original_result()
    }

    pub fn funder(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFunder")
            .original_result()
    }

    pub fn last_update_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastUpdateTime")
            .original_result()
    }

    pub fn reward_per_token_stored(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardPerTokenStored")
            .original_result()
    }

    /// Stake SFT/NFTs. 
    /// Payment: 1 single payment accepted. 
    pub fn stake(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .original_result()
    }

    /// Untake SFT/NFTs by sending a staked NFT receipt. 
    /// Payment: 1 single payment accepted. 
    pub fn unstake(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("unstake")
            .original_result()
    }

    /// Untake SFT/NFTs for multiple positions at once. 
    /// Payment(s): 1..N "staked NFT(s)". 
    pub fn unstake_multi(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("unstakeMulti")
            .original_result()
    }

    /// Claim rewards. 
    /// Payment: 1 single "staked NFT". 
    pub fn claim_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("claimRewards")
            .original_result()
    }

    /// Claim rewards for multiple positions at once. 
    /// Payment(s): 1..N "staked NFT(s)". 
    pub fn claim_rewards_multi(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("claimRewardsMulti")
            .original_result()
    }

    pub fn get_pending_rewards_view<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        staked_amount: Arg0,
        user_reward_per_token_paid: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue3<BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingRewards")
            .argument(&staked_amount)
            .argument(&user_reward_per_token_paid)
            .original_result()
    }

    pub fn issue_staked_nft_collection<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_name: Arg0,
        token_ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueStakedNftCollection")
            .argument(&token_name)
            .argument(&token_ticker)
            .original_result()
    }

    pub fn fund_rewards_and_set_duration<
        Arg0: ProxyArg<u64>,
    >(
        self,
        duration_in_seconds: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("fundRewardsAndSetDuration")
            .argument(&duration_in_seconds)
            .original_result()
    }

    pub fn reset_pool(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reset")
            .original_result()
    }

    pub fn set_performance_fee_percent_endpoint<
        Arg0: ProxyArg<u32>,
    >(
        self,
        fee_percent: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPerformanceFeePercent")
            .argument(&fee_percent)
            .original_result()
    }

    pub fn set_fee_receiver<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_receiver: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setFeeReceiver")
            .argument(&new_receiver)
            .original_result()
    }

    pub fn set_funder<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setFunder")
            .argument(&new_account)
            .original_result()
    }

    pub fn current_reward_per_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentRewardPerToken")
            .original_result()
    }

    pub fn get_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStatus")
            .original_result()
    }

    pub fn is_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn add_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn remove_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn admins(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmins")
            .original_result()
    }
}

#[type_abi]
#[derive(ManagedVecItem, NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct Status<Api>
where
    Api: ManagedTypeApi,
{
    pub staking_sft_collection_id: EsdtTokenIdentifier<Api>,
    pub min_nonce_id: u64,
    pub max_nonce_id: u64,
    pub total_staked: BigUint<Api>,
    pub reward_token: EgldOrEsdtTokenIdentifier<Api>,
    pub staked_nft_collection_id: Option<EsdtTokenIdentifier<Api>>,
    pub reward_start_time: u64,
    pub reward_end_time: u64,
    pub reward_per_second: BigUint<Api>,
    pub reward_per_token: BigUint<Api>,
    pub fee_receiver: ManagedAddress<Api>,
    pub performance_fee: u32,
    pub funder: ManagedAddress<Api>,
}
